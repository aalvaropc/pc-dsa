# ğŸ“Š 347. Top K Frequent Elements / K Elementos MÃ¡s Frecuentes

## ğŸ‡¬ğŸ‡§ English

**Problem:**  
Given an integer array `nums` and an integer `k`, return the **`k` most frequent elements**.  
You may return the answer in **any order**.

---

### Example 1
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]


### Example 2
Input: nums = [1], k = 1
Output: [1]

### Example 3
Input: nums = [1,2,1,2,1,2,3,1,3,2], k = 2
Output: [1,2]

---

### Constraints
- 1 <= nums.length <= 10âµ  
- -10â´ <= nums[i] <= 10â´  
- `k` is in the range `[1, number of unique elements]`.  
- It is guaranteed that the answer is unique.

---

**Follow-up:**  
Your algorithmâ€™s time complexity must be better than **O(n log n)**, where `n` is the array size.

---

## ğŸ‡ªğŸ‡¸ EspaÃ±ol

**Problema:**  
Dado un arreglo de enteros `nums` y un entero `k`, devuelve los **`k` elementos mÃ¡s frecuentes**.  
Puedes devolver la respuesta en **cualquier orden**.

---

### Ejemplo 1
Entrada: nums = [1,1,1,2,2,3], k = 2
Salida: [1,2]

### Ejemplo 2
Entrada: nums = [1], k = 1
Salida: [1]

### Ejemplo 3
Entrada: nums = [1,2,1,2,1,2,3,1,3,2], k = 2
Salida: [1,2]

---

### Restricciones
- 1 <= nums.length <= 10âµ  
- -10â´ <= nums[i] <= 10â´  
- `k` estÃ¡ en el rango `[1, nÃºmero de elementos Ãºnicos]`.  
- Se garantiza que la respuesta es Ãºnica.

---

**Pregunta adicional:**  
La complejidad temporal de tu algoritmo debe ser mejor que **O(n log n)**, donde `n` es el tamaÃ±o del arreglo.